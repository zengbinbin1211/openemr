"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('./logic'),
    ThreeValuedLogic = _require.ThreeValuedLogic;

var Uncertainty = /*#__PURE__*/function () {
  _createClass(Uncertainty, null, [{
    key: "from",
    value: function from(obj) {
      if (obj != null && obj.isUncertainty) {
        return obj;
      } else {
        return new Uncertainty(obj);
      }
    }
  }]);

  function Uncertainty() {
    var low = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var high = arguments.length > 1 ? arguments[1] : undefined;

    _classCallCheck(this, Uncertainty);

    this.low = low;
    this.high = high;

    var gt = function gt(a, b) {
      if (_typeof(a) !== _typeof(b)) {
        // TODO: This should probably throw rather than return false.
        // Uncertainties with different types probably shouldn't be supported.
        return false;
      }

      if (typeof a.after === 'function') {
        return a.after(b);
      } else {
        return a > b;
      }
    };

    var isNonEnumerable = function isNonEnumerable(val) {
      return val != null && (val.isCode || val.isConcept || val.isValueSet);
    };

    if (typeof this.high === 'undefined') {
      this.high = this.low;
    }

    if (isNonEnumerable(this.low) || isNonEnumerable(this.high)) {
      this.low = this.high = null;
    }

    if (this.low != null && this.high != null && gt(this.low, this.high)) {
      var _ref = [this.high, this.low];
      this.low = _ref[0];
      this.high = _ref[1];
    }
  }

  _createClass(Uncertainty, [{
    key: "copy",
    value: function copy() {
      var newLow = this.low;
      var newHigh = this.high;

      if (typeof this.low.copy === 'function') {
        newLow = this.low.copy();
      }

      if (typeof this.high.copy === 'function') {
        newHigh = this.high.copy();
      }

      return new Uncertainty(newLow, newHigh);
    }
  }, {
    key: "isPoint",
    value: function isPoint() {
      // Note: Can't use normal equality, as that fails for Javascript dates
      // TODO: Fix after we don't need to support Javascript date uncertainties anymore
      var lte = function lte(a, b) {
        if (_typeof(a) !== _typeof(b)) {
          return false;
        }

        if (typeof a.sameOrBefore === 'function') {
          return a.sameOrBefore(b);
        } else {
          return a <= b;
        }
      };

      var gte = function gte(a, b) {
        if (_typeof(a) !== _typeof(b)) {
          return false;
        }

        if (typeof a.sameOrBefore === 'function') {
          return a.sameOrAfter(b);
        } else {
          return a >= b;
        }
      };

      return this.low != null && this.high != null && lte(this.low, this.high) && gte(this.low, this.high);
    }
  }, {
    key: "equals",
    value: function equals(other) {
      other = Uncertainty.from(other);
      return ThreeValuedLogic.not(ThreeValuedLogic.or(this.lessThan(other), this.greaterThan(other)));
    }
  }, {
    key: "lessThan",
    value: function lessThan(other) {
      var lt = function lt(a, b) {
        if (_typeof(a) !== _typeof(b)) {
          return false;
        }

        if (typeof a.before === 'function') {
          return a.before(b);
        } else {
          return a < b;
        }
      };

      other = Uncertainty.from(other);
      var bestCase = this.low == null || other.high == null || lt(this.low, other.high);
      var worstCase = this.high != null && other.low != null && lt(this.high, other.low);

      if (bestCase === worstCase) {
        return bestCase;
      } else {
        return null;
      }
    }
  }, {
    key: "greaterThan",
    value: function greaterThan(other) {
      return Uncertainty.from(other).lessThan(this);
    }
  }, {
    key: "lessThanOrEquals",
    value: function lessThanOrEquals(other) {
      return ThreeValuedLogic.not(this.greaterThan(Uncertainty.from(other)));
    }
  }, {
    key: "greaterThanOrEquals",
    value: function greaterThanOrEquals(other) {
      return ThreeValuedLogic.not(this.lessThan(Uncertainty.from(other)));
    }
  }, {
    key: "isUncertainty",
    get: function get() {
      return true;
    }
  }]);

  return Uncertainty;
}();

module.exports = {
  Uncertainty: Uncertainty
};