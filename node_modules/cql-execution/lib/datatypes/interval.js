"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('./uncertainty'),
    Uncertainty = _require.Uncertainty;

var _require2 = require('../datatypes/quantity'),
    Quantity = _require2.Quantity,
    doSubtraction = _require2.doSubtraction;

var _require3 = require('./logic'),
    ThreeValuedLogic = _require3.ThreeValuedLogic;

var _require4 = require('../util/math'),
    successor = _require4.successor,
    predecessor = _require4.predecessor,
    maxValueForInstance = _require4.maxValueForInstance,
    minValueForInstance = _require4.minValueForInstance,
    maxValueForType = _require4.maxValueForType,
    minValueForType = _require4.minValueForType;

var cmp = require('../util/comparison');

var Interval = /*#__PURE__*/function () {
  function Interval(low, high, lowClosed, highClosed, defaultPointType) {
    _classCallCheck(this, Interval);

    this.low = low;
    this.high = high;
    this.lowClosed = lowClosed != null ? lowClosed : true;
    this.highClosed = highClosed != null ? highClosed : true; // defaultPointType is used in the case that both endpoints are null

    this.defaultPointType = defaultPointType;
  }

  _createClass(Interval, [{
    key: "copy",
    value: function copy() {
      var newLow = this.low;
      var newHigh = this.high;

      if (this.low != null && typeof this.low.copy === 'function') {
        newLow = this.low.copy();
      }

      if (this.high != null && typeof this.high.copy === 'function') {
        newHigh = this.high.copy();
      }

      return new Interval(newLow, newHigh, this.lowClosed, this.highClosed);
    }
  }, {
    key: "contains",
    value: function contains(item, precision) {
      // These first two checks ensure correct handling of edge case where an item equals the closed boundary
      if (this.lowClosed && this.low != null && cmp.equals(this.low, item)) {
        return true;
      }

      if (this.highClosed && this.high != null && cmp.equals(this.high, item)) {
        return true;
      }

      if (item != null && item.isInterval) {
        throw new Error('Argument to contains must be a point');
      }

      var lowFn;

      if (this.lowClosed && this.low == null) {
        lowFn = function lowFn() {
          return true;
        };
      } else if (this.lowClosed) {
        lowFn = cmp.lessThanOrEquals;
      } else {
        lowFn = cmp.lessThan;
      }

      var highFn;

      if (this.highClosed && this.high == null) {
        highFn = function highFn() {
          return true;
        };
      } else if (this.highClosed) {
        highFn = cmp.greaterThanOrEquals;
      } else {
        highFn = cmp.greaterThan;
      }

      return ThreeValuedLogic.and(lowFn(this.low, item, precision), highFn(this.high, item, precision));
    }
  }, {
    key: "properlyIncludes",
    value: function properlyIncludes(other, precision) {
      if (other == null || !other.isInterval) {
        throw new Error('Argument to properlyIncludes must be an interval');
      }

      return ThreeValuedLogic.and(this.includes(other, precision), ThreeValuedLogic.not(other.includes(this, precision)));
    }
  }, {
    key: "includes",
    value: function includes(other, precision) {
      if (other == null || !other.isInterval) {
        return this.contains(other, precision);
      }

      var a = this.toClosed();
      var b = other.toClosed();
      return ThreeValuedLogic.and(cmp.lessThanOrEquals(a.low, b.low, precision), cmp.greaterThanOrEquals(a.high, b.high, precision));
    }
  }, {
    key: "includedIn",
    value: function includedIn(other, precision) {
      // For the point overload, this operator is a synonym for the in operator
      if (other == null || !other.isInterval) {
        return this.contains(other, precision);
      } else {
        return other.includes(this);
      }
    }
  }, {
    key: "overlaps",
    value: function overlaps(item, precision) {
      var closed = this.toClosed();

      var _ref = function () {
        if (item != null && item.isInterval) {
          var itemClosed = item.toClosed();
          return [itemClosed.low, itemClosed.high];
        } else {
          return [item, item];
        }
      }(),
          _ref2 = _slicedToArray(_ref, 2),
          low = _ref2[0],
          high = _ref2[1];

      return ThreeValuedLogic.and(cmp.lessThanOrEquals(closed.low, high, precision), cmp.greaterThanOrEquals(closed.high, low, precision));
    }
  }, {
    key: "overlapsAfter",
    value: function overlapsAfter(item, precision) {
      var closed = this.toClosed();
      var high = item != null && item.isInterval ? item.toClosed().high : item;
      return ThreeValuedLogic.and(cmp.lessThanOrEquals(closed.low, high, precision), cmp.greaterThan(closed.high, high, precision));
    }
  }, {
    key: "overlapsBefore",
    value: function overlapsBefore(item, precision) {
      var closed = this.toClosed();
      var low = item != null && item.isInterval ? item.toClosed().low : item;
      return ThreeValuedLogic.and(cmp.lessThan(closed.low, low, precision), cmp.greaterThanOrEquals(closed.high, low, precision));
    }
  }, {
    key: "union",
    value: function union(other) {
      if (other == null || !other.isInterval) {
        throw new Error('Argument to union must be an interval');
      } // Note that interval union is only defined if the arguments overlap or meet.


      if (this.overlaps(other) || this.meets(other)) {
        var _ref3 = [this.toClosed(), other.toClosed()],
            a = _ref3[0],
            b = _ref3[1];
        var l, lc;

        if (cmp.lessThanOrEquals(a.low, b.low)) {
          var _ref4 = [this.low, this.lowClosed];
          l = _ref4[0];
          lc = _ref4[1];
        } else if (cmp.greaterThanOrEquals(a.low, b.low)) {
          var _ref5 = [other.low, other.lowClosed];
          l = _ref5[0];
          lc = _ref5[1];
        } else if (areNumeric(a.low, b.low)) {
          var _ref6 = [lowestNumericUncertainty(a.low, b.low), true];
          l = _ref6[0];
          lc = _ref6[1];
        } else if (areDateTimes(a.low, b.low) && a.low.isMorePrecise(b.low)) {
          var _ref7 = [other.low, other.lowClosed];
          l = _ref7[0];
          lc = _ref7[1];
        } else {
          var _ref8 = [this.low, this.lowClosed];
          l = _ref8[0];
          lc = _ref8[1];
        }

        var h, hc;

        if (cmp.greaterThanOrEquals(a.high, b.high)) {
          var _ref9 = [this.high, this.highClosed];
          h = _ref9[0];
          hc = _ref9[1];
        } else if (cmp.lessThanOrEquals(a.high, b.high)) {
          var _ref10 = [other.high, other.highClosed];
          h = _ref10[0];
          hc = _ref10[1];
        } else if (areNumeric(a.high, b.high)) {
          var _ref11 = [highestNumericUncertainty(a.high, b.high), true];
          h = _ref11[0];
          hc = _ref11[1];
        } else if (areDateTimes(a.high, b.high) && a.high.isMorePrecise(b.high)) {
          var _ref12 = [other.high, other.highClosed];
          h = _ref12[0];
          hc = _ref12[1];
        } else {
          var _ref13 = [this.high, this.highClosed];
          h = _ref13[0];
          hc = _ref13[1];
        }

        return new Interval(l, h, lc, hc);
      } else {
        return null;
      }
    }
  }, {
    key: "intersect",
    value: function intersect(other) {
      if (other == null || !other.isInterval) {
        throw new Error('Argument to union must be an interval');
      } // Note that interval union is only defined if the arguments overlap.


      if (this.overlaps(other)) {
        var _ref14 = [this.toClosed(), other.toClosed()],
            a = _ref14[0],
            b = _ref14[1];
        var l, lc;

        if (cmp.greaterThanOrEquals(a.low, b.low)) {
          var _ref15 = [this.low, this.lowClosed];
          l = _ref15[0];
          lc = _ref15[1];
        } else if (cmp.lessThanOrEquals(a.low, b.low)) {
          var _ref16 = [other.low, other.lowClosed];
          l = _ref16[0];
          lc = _ref16[1];
        } else if (areNumeric(a.low, b.low)) {
          var _ref17 = [highestNumericUncertainty(a.low, b.low), true];
          l = _ref17[0];
          lc = _ref17[1];
        } else if (areDateTimes(a.low, b.low) && b.low.isMorePrecise(a.low)) {
          var _ref18 = [other.low, other.lowClosed];
          l = _ref18[0];
          lc = _ref18[1];
        } else {
          var _ref19 = [this.low, this.lowClosed];
          l = _ref19[0];
          lc = _ref19[1];
        }

        var h, hc;

        if (cmp.lessThanOrEquals(a.high, b.high)) {
          var _ref20 = [this.high, this.highClosed];
          h = _ref20[0];
          hc = _ref20[1];
        } else if (cmp.greaterThanOrEquals(a.high, b.high)) {
          var _ref21 = [other.high, other.highClosed];
          h = _ref21[0];
          hc = _ref21[1];
        } else if (areNumeric(a.high, b.high)) {
          var _ref22 = [lowestNumericUncertainty(a.high, b.high), true];
          h = _ref22[0];
          hc = _ref22[1];
        } else if (areDateTimes(a.high, b.high) && b.high.isMorePrecise(a.high)) {
          var _ref23 = [other.high, other.highClosed];
          h = _ref23[0];
          hc = _ref23[1];
        } else {
          var _ref24 = [this.high, this.highClosed];
          h = _ref24[0];
          hc = _ref24[1];
        }

        return new Interval(l, h, lc, hc);
      } else {
        return null;
      }
    }
  }, {
    key: "except",
    value: function except(other) {
      if (other === null) {
        return null;
      }

      if (other == null || !other.isInterval) {
        throw new Error('Argument to except must be an interval');
      }

      var ol = this.overlaps(other);

      if (ol === true) {
        var olb = this.overlapsBefore(other);
        var ola = this.overlapsAfter(other);

        if (olb === true && ola === false) {
          return new Interval(this.low, other.low, this.lowClosed, !other.lowClosed);
        } else if (ola === true && olb === false) {
          return new Interval(other.high, this.high, !other.highClosed, this.highClosed);
        } else {
          return null;
        }
      } else if (ol === false) {
        return this;
      } else {
        // ol is null
        return null;
      }
    }
  }, {
    key: "sameAs",
    value: function sameAs(other, precision) {
      // This large if and else if block handles the scenarios where there is an open ended null
      // If both lows or highs exists, it can be determined that intervals are not Same As
      if (this.low != null && other.low != null && this.high == null && other.high != null && !this.highClosed || this.low != null && other.low != null && this.high != null && other.high == null && !other.highClosed || this.low != null && other.low != null && this.high == null && other.high == null && !other.highClosed && !this.highClosed) {
        if (typeof this.low === 'number') {
          if (!(this.start() === other.start())) {
            return false;
          }
        } else {
          if (!this.start().sameAs(other.start(), precision)) {
            return false;
          }
        }
      } else if (this.low != null && other.low == null && this.high != null && other.high != null || this.low == null && other.low != null && this.high != null && other.high != null || this.low == null && other.low == null && this.high != null && other.high != null) {
        if (typeof this.high === 'number') {
          if (!(this.end() === other.end())) {
            return false;
          }
        } else {
          if (!this.end().sameAs(other.end(), precision)) {
            return false;
          }
        }
      } // Checks to see if any of the Intervals have a open, null boundary


      if (this.low == null && !this.lowClosed || this.high == null && !this.highClosed || other.low == null && !other.lowClosed || other.high == null && !other.highClosed) {
        return null;
      } // For the special cases where @ is Interval[null,null]


      if (this.lowClosed && this.low == null && this.highClosed && this.high == null) {
        return other.lowClosed && other.low == null && other.highClosed && other.high == null;
      } // For the special case where Interval[...] same as Interval[null,null] should return false.
      // This accounts for the inverse of the if statement above: where the second Interval is
      // [null,null] and not the first Interval.
      // The reason why this isn't caught below is due to how start() and end() work.
      // There is no way to tell the datatype for MIN and MAX if both boundaries are null.


      if (other.lowClosed && other.low == null && other.highClosed && other.high == null) {
        return false;
      }

      if (typeof this.low === 'number') {
        return this.start() === other.start() && this.end() === other.end();
      } else {
        return this.start().sameAs(other.start(), precision) && this.end().sameAs(other.end(), precision);
      }
    }
  }, {
    key: "sameOrBefore",
    value: function sameOrBefore(other, precision) {
      if (this.end() == null || other == null || other.start() == null) {
        return null;
      } else {
        return cmp.lessThanOrEquals(this.end(), other.start(), precision);
      }
    }
  }, {
    key: "sameOrAfter",
    value: function sameOrAfter(other, precision) {
      if (this.start() == null || other == null || other.end() == null) {
        return null;
      } else {
        return cmp.greaterThanOrEquals(this.start(), other.end(), precision);
      }
    }
  }, {
    key: "equals",
    value: function equals(other) {
      if (other != null && other.isInterval) {
        var _ref25 = [this.toClosed(), other.toClosed()],
            a = _ref25[0],
            b = _ref25[1];
        return ThreeValuedLogic.and(cmp.equals(a.low, b.low), cmp.equals(a.high, b.high));
      } else {
        return false;
      }
    }
  }, {
    key: "after",
    value: function after(other, precision) {
      var closed = this.toClosed(); // Meets spec, but not 100% correct (e.g., (null, 5] after [6, 10] --> null)
      // Simple way to fix it: and w/ not overlaps

      if (other.toClosed) {
        return cmp.greaterThan(closed.low, other.toClosed().high, precision);
      } else {
        return cmp.greaterThan(closed.low, other, precision);
      }
    }
  }, {
    key: "before",
    value: function before(other, precision) {
      var closed = this.toClosed(); // Meets spec, but not 100% correct (e.g., (null, 5] after [6, 10] --> null)
      // Simple way to fix it: and w/ not overlaps

      if (other.toClosed) {
        return cmp.lessThan(closed.high, other.toClosed().low, precision);
      } else {
        return cmp.lessThan(closed.high, other, precision);
      }
    }
  }, {
    key: "meets",
    value: function meets(other, precision) {
      return ThreeValuedLogic.or(this.meetsBefore(other, precision), this.meetsAfter(other, precision));
    }
  }, {
    key: "meetsAfter",
    value: function meetsAfter(other, precision) {
      try {
        if (precision != null && this.low != null && this.low.isDateTime) {
          return this.toClosed().low.sameAs(other.toClosed().high != null ? other.toClosed().high.add(1, precision) : null, precision);
        } else {
          return cmp.equals(this.toClosed().low, successor(other.toClosed().high));
        }
      } catch (error) {
        return false;
      }
    }
  }, {
    key: "meetsBefore",
    value: function meetsBefore(other, precision) {
      try {
        if (precision != null && this.high != null && this.high.isDateTime) {
          return this.toClosed().high.sameAs(other.toClosed().low != null ? other.toClosed().low.add(-1, precision) : null, precision);
        } else {
          return cmp.equals(this.toClosed().high, predecessor(other.toClosed().low));
        }
      } catch (error) {
        return false;
      }
    }
  }, {
    key: "start",
    value: function start() {
      if (this.low == null) {
        if (this.lowClosed) {
          return minValueForInstance(this.high);
        } else {
          return this.low;
        }
      }

      return this.toClosed().low;
    }
  }, {
    key: "end",
    value: function end() {
      if (this.high == null) {
        if (this.highClosed) {
          return maxValueForInstance(this.low);
        } else {
          return this.high;
        }
      }

      return this.toClosed().high;
    }
  }, {
    key: "starts",
    value: function starts(other, precision) {
      var startEqual;

      if (precision != null && this.low != null && this.low.isDateTime) {
        startEqual = this.low.sameAs(other.low, precision);
      } else {
        startEqual = cmp.equals(this.low, other.low);
      }

      var endLessThanOrEqual = cmp.lessThanOrEquals(this.high, other.high, precision);
      return startEqual && endLessThanOrEqual;
    }
  }, {
    key: "ends",
    value: function ends(other, precision) {
      var endEqual;
      var startGreaterThanOrEqual = cmp.greaterThanOrEquals(this.low, other.low, precision);

      if (precision != null && (this.low != null ? this.low.isDateTime : undefined)) {
        endEqual = this.high.sameAs(other.high, precision);
      } else {
        endEqual = cmp.equals(this.high, other.high);
      }

      return startGreaterThanOrEqual && endEqual;
    }
  }, {
    key: "width",
    value: function width() {
      if (this.low != null && (this.low.isDateTime || this.low.isDate) || this.high != null && (this.high.isDateTime || this.high.isDate)) {
        throw new Error('Width of Date, DateTime, and Time intervals is not supported');
      }

      var closed = this.toClosed();

      if (closed.low != null && closed.low.isUncertainty || closed.high != null && closed.high.isUncertainty) {
        return null;
      } else if (closed.low.isQuantity) {
        if (closed.low.unit !== closed.high.unit) {
          throw new Error('Cannot calculate width of Quantity Interval with different units');
        }

        var lowValue = closed.low.value;
        var highValue = closed.high.value;
        var diff = Math.abs(highValue - lowValue);
        diff = Math.round(diff * Math.pow(10, 8)) / Math.pow(10, 8);
        return new Quantity(diff, closed.low.unit);
      } else {
        // TODO: Fix precision to 8 decimals in other places that return numbers
        var _diff = Math.abs(closed.high - closed.low);

        return Math.round(_diff * Math.pow(10, 8)) / Math.pow(10, 8);
      }
    }
  }, {
    key: "size",
    value: function size() {
      var pointSize = this.getPointSize();

      if (this.low != null && (this.low.isDateTime || this.low.isDate) || this.high != null && (this.high.isDateTime || this.high.isDate)) {
        throw new Error('Size of Date, DateTime, and Time intervals is not supported');
      }

      var closed = this.toClosed();

      if (closed.low != null && closed.low.isUncertainty || closed.high != null && closed.high.isUncertainty) {
        return null;
      } else if (closed.low.isQuantity) {
        if (closed.low.unit !== closed.high.unit) {
          throw new Error('Cannot calculate size of Quantity Interval with different units');
        }

        var lowValue = closed.low.value;
        var highValue = closed.high.value;
        var diff = Math.abs(highValue - lowValue) + pointSize.value;
        Math.round(diff * Math.pow(10, 8)) / Math.pow(10, 8);
        return new Quantity(diff, closed.low.unit);
      } else {
        var _diff2 = Math.abs(closed.high - closed.low) + pointSize.value;

        return Math.round(_diff2 * Math.pow(10, 8)) / Math.pow(10, 8);
      }
    }
  }, {
    key: "getPointSize",
    value: function getPointSize() {
      var pointSize;

      if (this.low != null) {
        if (this.low.isDateTime) {
          pointSize = new Quantity(1, this.low.getPrecision());
        } else if (this.low.isQuantity) {
          pointSize = doSubtraction(successor(this.low), this.low);
        } else {
          pointSize = successor(this.low) - this.low;
        }
      } else if (this.high != null) {
        if (this.high.isDateTime) {
          pointSize = new Quantity(1, this.high.getPrecision());
        } else if (this.high.isQuantity) {
          pointSize = doSubtraction(successor(this.high), this.high);
        } else {
          pointSize = successor(this.high) - this.high;
        }
      } else {
        throw new Error('Point type of intervals cannot be determined.');
      }

      if (typeof pointSize === 'number') {
        pointSize = new Quantity(pointSize, '1');
      }

      return pointSize;
    }
  }, {
    key: "toClosed",
    value: function toClosed() {
      // Calculate the closed flags. Despite the name of this function, if a boundary is null open,
      // we cannot close the boundary because that changes its meaning from "unknown" to "max/min value"
      var lowClosed = this.lowClosed || this.low != null;
      var highClosed = this.highClosed || this.high != null;

      if (this.pointType != null) {
        var low;

        if (this.lowClosed && this.low == null) {
          low = minValueForType(this.pointType);
        } else if (!this.lowClosed && this.low != null) {
          low = successor(this.low);
        } else {
          low = this.low;
        }

        var high;

        if (this.highClosed && this.high == null) {
          high = maxValueForType(this.pointType);
        } else if (!this.highClosed && this.high != null) {
          high = predecessor(this.high);
        } else {
          high = this.high;
        }

        if (low == null) {
          low = new Uncertainty(minValueForType(this.pointType), high);
        }

        if (high == null) {
          high = new Uncertainty(low, maxValueForType(this.pointType));
        }

        return new Interval(low, high, lowClosed, highClosed);
      } else {
        return new Interval(this.low, this.high, lowClosed, highClosed);
      }
    }
  }, {
    key: "toString",
    value: function toString() {
      var start = this.lowClosed ? '[' : '(';
      var end = this.highClosed ? ']' : ')';
      return start + this.low.toString() + ', ' + this.high.toString() + end;
    }
  }, {
    key: "isInterval",
    get: function get() {
      return true;
    }
  }, {
    key: "pointType",
    get: function get() {
      var pointType = null;
      var point = this.low != null ? this.low : this.high;

      if (point != null) {
        if (typeof point === 'number') {
          pointType = parseInt(point) === point ? '{urn:hl7-org:elm-types:r1}Integer' : '{urn:hl7-org:elm-types:r1}Decimal';
        } else if (point.isTime && point.isTime()) {
          pointType = '{urn:hl7-org:elm-types:r1}Time';
        } else if (point.isDate) {
          pointType = '{urn:hl7-org:elm-types:r1}Date';
        } else if (point.isDateTime) {
          pointType = '{urn:hl7-org:elm-types:r1}DateTime';
        } else if (point.isQuantity) {
          pointType = '{urn:hl7-org:elm-types:r1}Quantity';
        }
      }

      if (pointType == null && this.defaultPointType != null) {
        pointType = this.defaultPointType;
      }

      return pointType;
    }
  }]);

  return Interval;
}();

function areDateTimes(x, y) {
  return [x, y].every(function (z) {
    return z != null && z.isDateTime;
  });
}

function areNumeric(x, y) {
  return [x, y].every(function (z) {
    return typeof z === 'number' || z != null && z.isUncertainty && typeof z.low === 'number';
  });
}

function lowestNumericUncertainty(x, y) {
  if (x == null || !x.isUncertainty) {
    x = new Uncertainty(x);
  }

  if (y == null || !y.isUncertainty) {
    y = new Uncertainty(y);
  }

  var low = x.low < y.low ? x.low : y.low;
  var high = x.high < y.high ? x.high : y.high;

  if (low !== high) {
    return new Uncertainty(low, high);
  } else {
    return low;
  }
}

function highestNumericUncertainty(x, y) {
  if (x == null || !x.isUncertainty) {
    x = new Uncertainty(x);
  }

  if (y == null || !y.isUncertainty) {
    y = new Uncertainty(y);
  }

  var low = x.low > y.low ? x.low : y.low;
  var high = x.high > y.high ? x.high : y.high;

  if (low !== high) {
    return new Uncertainty(low, high);
  } else {
    return low;
  }
}

module.exports = {
  Interval: Interval
};