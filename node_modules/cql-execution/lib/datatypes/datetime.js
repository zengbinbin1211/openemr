"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('./uncertainty'),
    Uncertainty = _require.Uncertainty;

var _require2 = require('../util/util'),
    jsDate = _require2.jsDate,
    normalizeMillisecondsField = _require2.normalizeMillisecondsField,
    normalizeMillisecondsFieldInString = _require2.normalizeMillisecondsFieldInString;

var luxon = require('luxon'); // It's easiest and most performant to organize formats by length of the supported strings.
// This way we can test strings only against the formats that have a chance of working.
// NOTE: Formats use Luxon formats, documented here: https://moment.github.io/luxon/docs/manual/parsing.html#table-of-tokens


var LENGTH_TO_DATE_FORMAT_MAP = function () {
  var ltdfMap = new Map();
  ltdfMap.set(4, 'yyyy');
  ltdfMap.set(7, 'yyyy-MM');
  ltdfMap.set(10, 'yyyy-MM-dd');
  return ltdfMap;
}();

var LENGTH_TO_DATETIME_FORMATS_MAP = function () {
  var formats = {
    yyyy: '2012',
    'yyyy-MM': '2012-01',
    'yyyy-MM-dd': '2012-01-31',
    "yyyy-MM-dd'T''Z'": '2012-01-31TZ',
    "yyyy-MM-dd'T'ZZ": '2012-01-31T-04:00',
    "yyyy-MM-dd'T'HH": '2012-01-31T12',
    "yyyy-MM-dd'T'HH'Z'": '2012-01-31T12Z',
    "yyyy-MM-dd'T'HHZZ": '2012-01-31T12-04:00',
    "yyyy-MM-dd'T'HH:mm": '2012-01-31T12:30',
    "yyyy-MM-dd'T'HH:mm'Z'": '2012-01-31T12:30Z',
    "yyyy-MM-dd'T'HH:mmZZ": '2012-01-31T12:30-04:00',
    "yyyy-MM-dd'T'HH:mm:ss": '2012-01-31T12:30:59',
    "yyyy-MM-dd'T'HH:mm:ss'Z'": '2012-01-31T12:30:59Z',
    "yyyy-MM-dd'T'HH:mm:ssZZ": '2012-01-31T12:30:59-04:00',
    "yyyy-MM-dd'T'HH:mm:ss.SSS": '2012-01-31T12:30:59.000',
    "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'": '2012-01-31T12:30:59.000Z',
    "yyyy-MM-dd'T'HH:mm:ss.SSSZZ": '2012-01-31T12:30:59.000-04:00'
  };
  var ltdtfMap = new Map();
  Object.keys(formats).forEach(function (k) {
    var example = formats[k];

    if (!ltdtfMap.has(example.length)) {
      ltdtfMap.set(example.length, [k]);
    } else {
      ltdtfMap.get(example.length).push(k);
    }
  });
  return ltdtfMap;
}();

function wholeLuxonDuration(duration, unit) {
  var value = duration.get(unit);
  return value >= 0 ? Math.floor(value) : Math.ceil(value);
}

function truncateLuxonDateTime(luxonDT, unit) {
  // Truncating by week (to the previous Sunday) requires different logic than the rest
  if (unit === DateTime.Unit.WEEK) {
    // Sunday is ISO weekday 7
    if (luxonDT.weekday !== 7) {
      luxonDT = luxonDT.set({
        weekday: 7
      }).minus({
        weeks: 1
      });
    }

    unit = DateTime.Unit.DAY;
  }

  return luxonDT.startOf(unit);
}

var DateTime = /*#__PURE__*/function () {
  _createClass(DateTime, null, [{
    key: "parse",
    value: function parse(string) {
      if (string === null) {
        return null;
      }

      var matches = /(\d{4})(-(\d{2}))?(-(\d{2}))?(T((\d{2})(:(\d{2})(:(\d{2})(\.(\d+))?)?)?)?(Z|(([+-])(\d{2})(:?(\d{2}))?))?)?/.exec(string);

      if (matches == null) {
        return null;
      }

      var years = matches[1];
      var months = matches[3];
      var days = matches[5];
      var hours = matches[8];
      var minutes = matches[10];
      var seconds = matches[12];
      var milliseconds = matches[14];

      if (milliseconds != null) {
        milliseconds = normalizeMillisecondsField(milliseconds);
      }

      if (milliseconds != null) {
        string = normalizeMillisecondsFieldInString(string, matches[14]);
      }

      if (!isValidDateTimeStringFormat(string)) {
        return null;
      } // convert the args to integers


      var args = [years, months, days, hours, minutes, seconds, milliseconds].map(function (arg) {
        return arg != null ? parseInt(arg) : arg;
      }); // convert timezone offset to decimal and add it to arguments

      if (matches[18] != null) {
        var num = parseInt(matches[18]) + (matches[20] != null ? parseInt(matches[20]) / 60 : 0);
        args.push(matches[17] === '+' ? num : num * -1);
      } else if (matches[15] === 'Z') {
        args.push(0);
      }

      return _construct(DateTime, _toConsumableArray(args));
    }
  }, {
    key: "fromJSDate",
    value: function fromJSDate(date, timezoneOffset) {
      //This is from a JS Date, not a CQL Date
      if (date instanceof DateTime) {
        return date;
      }

      if (timezoneOffset != null) {
        date = new jsDate(date.getTime() + timezoneOffset * 60 * 60 * 1000);
        return new DateTime(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds(), timezoneOffset);
      } else {
        return new DateTime(date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
      }
    }
  }, {
    key: "fromLuxonDateTime",
    value: function fromLuxonDateTime(luxonDT) {
      if (luxonDT instanceof DateTime) {
        return luxonDT;
      }

      return new DateTime(luxonDT.year, luxonDT.month, luxonDT.day, luxonDT.hour, luxonDT.minute, luxonDT.second, luxonDT.millisecond, luxonDT.offset / 60);
    }
  }]);

  function DateTime() {
    var year = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var month = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var day = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var hour = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var minute = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var second = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var millisecond = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var timezoneOffset = arguments.length > 7 ? arguments[7] : undefined;

    _classCallCheck(this, DateTime);

    // from the spec: If no timezone is specified, the timezone of the evaluation request timestamp is used.
    // NOTE: timezoneOffset will be explicitly null for the Time overload, whereas
    // it will be undefined if simply unspecified
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond;
    this.timezoneOffset = timezoneOffset;

    if (this.timezoneOffset === undefined) {
      this.timezoneOffset = new jsDate().getTimezoneOffset() / 60 * -1;
    }
  }

  _createClass(DateTime, [{
    key: "copy",
    value: function copy() {
      return new DateTime(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond, this.timezoneOffset);
    }
  }, {
    key: "successor",
    value: function successor() {
      if (this.millisecond != null) {
        return this.add(1, DateTime.Unit.MILLISECOND);
      } else if (this.second != null) {
        return this.add(1, DateTime.Unit.SECOND);
      } else if (this.minute != null) {
        return this.add(1, DateTime.Unit.MINUTE);
      } else if (this.hour != null) {
        return this.add(1, DateTime.Unit.HOUR);
      } else if (this.day != null) {
        return this.add(1, DateTime.Unit.DAY);
      } else if (this.month != null) {
        return this.add(1, DateTime.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(1, DateTime.Unit.YEAR);
      }
    }
  }, {
    key: "predecessor",
    value: function predecessor() {
      if (this.millisecond != null) {
        return this.add(-1, DateTime.Unit.MILLISECOND);
      } else if (this.second != null) {
        return this.add(-1, DateTime.Unit.SECOND);
      } else if (this.minute != null) {
        return this.add(-1, DateTime.Unit.MINUTE);
      } else if (this.hour != null) {
        return this.add(-1, DateTime.Unit.HOUR);
      } else if (this.day != null) {
        return this.add(-1, DateTime.Unit.DAY);
      } else if (this.month != null) {
        return this.add(-1, DateTime.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(-1, DateTime.Unit.YEAR);
      }
    }
  }, {
    key: "convertToTimezoneOffset",
    value: function convertToTimezoneOffset() {
      var timezoneOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var shiftedLuxonDT = this.toLuxonDateTime().setZone(luxon.FixedOffsetZone.instance(timezoneOffset * 60));
      var shiftedDT = DateTime.fromLuxonDateTime(shiftedLuxonDT);
      return shiftedDT.reducedPrecision(this.getPrecision());
    }
  }, {
    key: "differenceBetween",
    value: function differenceBetween(other, unitField) {
      other = this._implicitlyConvert(other);

      if (other == null || !other.isDateTime) {
        return null;
      } // According to CQL spec:
      // * "Difference calculations are performed by truncating the datetime values at the next precision,
      //   and then performing the corresponding duration calculation on the truncated values."
      // * "When difference is calculated for hours or finer units, timezone offsets should be normalized
      //   prior to truncation to correctly consider real (actual elapsed) time. When difference is calculated
      //   for days or coarser units, however, the time components (including timezone offset) should be truncated
      //   without normalization to correctly reflect the difference in calendar days, months, and years."


      var a = this.toLuxonUncertainty();
      var b = other.toLuxonUncertainty(); // If unit is days or above, reset all the DateTimes to UTC since TZ offset should not be considered;
      // Otherwise, we don't actually have to "normalize" to a common TZ because Luxon takes TZ into account.

      if ([DateTime.Unit.YEAR, DateTime.Unit.MONTH, DateTime.Unit.WEEK, DateTime.Unit.DAY].includes(unitField)) {
        a.low = a.low.toUTC(0, {
          keepLocalTime: true
        });
        a.high = a.high.toUTC(0, {
          keepLocalTime: true
        });
        b.low = b.low.toUTC(0, {
          keepLocalTime: true
        });
        b.high = b.high.toUTC(0, {
          keepLocalTime: true
        });
      } // Truncate all dates at precision below specified unit


      a.low = truncateLuxonDateTime(a.low, unitField);
      a.high = truncateLuxonDateTime(a.high, unitField);
      b.low = truncateLuxonDateTime(b.low, unitField);
      b.high = truncateLuxonDateTime(b.high, unitField); // Return the duration based on the normalize and truncated values

      return new Uncertainty(wholeLuxonDuration(b.low.diff(a.high, unitField), unitField), wholeLuxonDuration(b.high.diff(a.low, unitField), unitField));
    }
  }, {
    key: "durationBetween",
    value: function durationBetween(other, unitField) {
      other = this._implicitlyConvert(other);

      if (other == null || !other.isDateTime) {
        return null;
      }

      var a = this.toLuxonUncertainty();
      var b = other.toLuxonUncertainty();
      return new Uncertainty(wholeLuxonDuration(b.low.diff(a.high, unitField), unitField), wholeLuxonDuration(b.high.diff(a.low, unitField), unitField));
    }
  }, {
    key: "isUTC",
    value: function isUTC() {
      // A timezoneOffset of 0 indicates UTC time.
      return !this.timezoneOffset;
    }
  }, {
    key: "getPrecision",
    value: function getPrecision() {
      var result = null;

      if (this.year != null) {
        result = DateTime.Unit.YEAR;
      } else {
        return result;
      }

      if (this.month != null) {
        result = DateTime.Unit.MONTH;
      } else {
        return result;
      }

      if (this.day != null) {
        result = DateTime.Unit.DAY;
      } else {
        return result;
      }

      if (this.hour != null) {
        result = DateTime.Unit.HOUR;
      } else {
        return result;
      }

      if (this.minute != null) {
        result = DateTime.Unit.MINUTE;
      } else {
        return result;
      }

      if (this.second != null) {
        result = DateTime.Unit.SECOND;
      } else {
        return result;
      }

      if (this.millisecond != null) {
        result = DateTime.Unit.MILLISECOND;
      }

      return result;
    }
  }, {
    key: "toLuxonDateTime",
    value: function toLuxonDateTime() {
      var offsetMins = this.timezoneOffset != null ? this.timezoneOffset * 60 : new jsDate().getTimezoneOffset() * -1;
      return luxon.DateTime.fromObject({
        year: this.year,
        month: this.month,
        day: this.day,
        hour: this.hour,
        minute: this.minute,
        second: this.second,
        millisecond: this.millisecond,
        zone: luxon.FixedOffsetZone.instance(offsetMins)
      });
    }
  }, {
    key: "toLuxonUncertainty",
    value: function toLuxonUncertainty() {
      var low = this.toLuxonDateTime();
      var high = low.endOf(this.getPrecision());
      return new Uncertainty(low, high);
    }
  }, {
    key: "toJSDate",
    value: function toJSDate() {
      var ignoreTimezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var luxonDT = this.toLuxonDateTime(); // I don't know if anyone is using "ignoreTimezone" anymore (we aren't), but just in case

      if (ignoreTimezone) {
        var offset = new jsDate().getTimezoneOffset() * -1;
        luxonDT = luxonDT.setZone(luxon.FixedOffsetZone.instance(offset), {
          keepLocalTime: true
        });
      }

      return luxonDT.toJSDate();
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toString();
    }
  }, {
    key: "_pad",
    value: function _pad(num) {
      return String('0' + num).slice(-2);
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this.isTime()) {
        return this.toStringTime();
      } else {
        return this.toStringDateTime();
      }
    }
  }, {
    key: "toStringTime",
    value: function toStringTime() {
      var str = '';

      if (this.hour != null) {
        str += this._pad(this.hour);

        if (this.minute != null) {
          str += ':' + this._pad(this.minute);

          if (this.second != null) {
            str += ':' + this._pad(this.second);

            if (this.millisecond != null) {
              str += '.' + String('00' + this.millisecond).slice(-3);
            }
          }
        }
      }

      return str;
    }
  }, {
    key: "toStringDateTime",
    value: function toStringDateTime() {
      var str = '';

      if (this.year != null) {
        str += this.year;

        if (this.month != null) {
          str += '-' + this._pad(this.month);

          if (this.day != null) {
            str += '-' + this._pad(this.day);

            if (this.hour != null) {
              str += 'T' + this._pad(this.hour);

              if (this.minute != null) {
                str += ':' + this._pad(this.minute);

                if (this.second != null) {
                  str += ':' + this._pad(this.second);

                  if (this.millisecond != null) {
                    str += '.' + String('00' + this.millisecond).slice(-3);
                  }
                }
              }
            }
          }
        }
      }

      if (str.indexOf('T') !== -1 && this.timezoneOffset != null) {
        str += this.timezoneOffset < 0 ? '-' : '+';
        var offsetHours = Math.floor(Math.abs(this.timezoneOffset));
        str += this._pad(offsetHours);
        var offsetMin = (Math.abs(this.timezoneOffset) - offsetHours) * 60;
        str += ':' + this._pad(offsetMin);
      }

      return str;
    }
  }, {
    key: "getDateTime",
    value: function getDateTime() {
      return this;
    }
  }, {
    key: "getDate",
    value: function getDate() {
      return new _Date(this.year, this.month, this.day);
    }
  }, {
    key: "getTime",
    value: function getTime() {
      // Times no longer have timezoneOffets, so we must explicitly set it to null
      return new DateTime(0, 1, 1, this.hour, this.minute, this.second, this.millisecond, null);
    }
  }, {
    key: "isTime",
    value: function isTime() {
      return this.year === 0 && this.month === 1 && this.day === 1;
    }
  }, {
    key: "_implicitlyConvert",
    value: function _implicitlyConvert(other) {
      if (other != null && other.isDate) {
        return other.getDateTime();
      }

      return other;
    }
  }, {
    key: "reducedPrecision",
    value: function reducedPrecision() {
      var unitField = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DateTime.Unit.MILLISECOND;
      var reduced = this.copy();

      if (unitField !== DateTime.Unit.MILLISECOND) {
        var fieldIndex = DateTime.FIELDS.indexOf(unitField);
        var fieldsToRemove = DateTime.FIELDS.slice(fieldIndex + 1);

        var _iterator = _createForOfIteratorHelper(fieldsToRemove),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var field = _step.value;
            reduced[field] = null;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return reduced;
    }
  }, {
    key: "isDateTime",
    get: function get() {
      return true;
    }
  }]);

  return DateTime;
}();

DateTime.Unit = {
  YEAR: 'year',
  MONTH: 'month',
  WEEK: 'week',
  DAY: 'day',
  HOUR: 'hour',
  MINUTE: 'minute',
  SECOND: 'second',
  MILLISECOND: 'millisecond'
};
DateTime.FIELDS = [DateTime.Unit.YEAR, DateTime.Unit.MONTH, DateTime.Unit.DAY, DateTime.Unit.HOUR, DateTime.Unit.MINUTE, DateTime.Unit.SECOND, DateTime.Unit.MILLISECOND];

var _Date = /*#__PURE__*/function () {
  _createClass(_Date, null, [{
    key: "parse",
    value: function parse(string) {
      if (string === null) {
        return null;
      }

      var matches = /(\d{4})(-(\d{2}))?(-(\d{2}))?/.exec(string);

      if (matches == null) {
        return null;
      }

      var years = matches[1];
      var months = matches[3];
      var days = matches[5];

      if (!isValidDateStringFormat(string)) {
        return null;
      } // convert args to integers


      var args = [years, months, days].map(function (arg) {
        return arg != null ? parseInt(arg) : arg;
      });
      return _construct(_Date, _toConsumableArray(args));
    }
  }]);

  function _Date() {
    var year = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var month = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var day = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, _Date);

    this.year = year;
    this.month = month;
    this.day = day;
  }

  _createClass(_Date, [{
    key: "copy",
    value: function copy() {
      return new _Date(this.year, this.month, this.day);
    }
  }, {
    key: "successor",
    value: function successor() {
      if (this.day != null) {
        return this.add(1, _Date.Unit.DAY);
      } else if (this.month != null) {
        return this.add(1, _Date.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(1, _Date.Unit.YEAR);
      }
    }
  }, {
    key: "predecessor",
    value: function predecessor() {
      if (this.day != null) {
        return this.add(-1, _Date.Unit.DAY);
      } else if (this.month != null) {
        return this.add(-1, _Date.Unit.MONTH);
      } else if (this.year != null) {
        return this.add(-1, _Date.Unit.YEAR);
      }
    }
  }, {
    key: "differenceBetween",
    value: function differenceBetween(other, unitField) {
      if (other != null && other.isDateTime) {
        return this.getDateTime().differenceBetween(other, unitField);
      }

      if (other == null || !other.isDate) {
        return null;
      } // According to CQL spec:
      // * "Difference calculations are performed by truncating the datetime values at the next precision,
      //   and then performing the corresponding duration calculation on the truncated values."


      var a = this.toLuxonUncertainty();
      var b = other.toLuxonUncertainty(); // Truncate all dates at precision below specified unit

      a.low = truncateLuxonDateTime(a.low, unitField);
      a.high = truncateLuxonDateTime(a.high, unitField);
      b.low = truncateLuxonDateTime(b.low, unitField);
      b.high = truncateLuxonDateTime(b.high, unitField); // Return the duration based on the normalize and truncated values

      return new Uncertainty(wholeLuxonDuration(b.low.diff(a.high, unitField), unitField), wholeLuxonDuration(b.high.diff(a.low, unitField), unitField));
    }
  }, {
    key: "durationBetween",
    value: function durationBetween(other, unitField) {
      if (other != null && other.isDateTime) {
        return this.getDateTime().durationBetween(other, unitField);
      }

      if (other == null || !other.isDate) {
        return null;
      }

      var a = this.toLuxonUncertainty();
      var b = other.toLuxonUncertainty();
      return new Uncertainty(wholeLuxonDuration(b.low.diff(a.high, unitField), unitField), wholeLuxonDuration(b.high.diff(a.low, unitField), unitField));
    }
  }, {
    key: "getPrecision",
    value: function getPrecision() {
      var result = null;

      if (this.year != null) {
        result = _Date.Unit.YEAR;
      } else {
        return result;
      }

      if (this.month != null) {
        result = _Date.Unit.MONTH;
      } else {
        return result;
      }

      if (this.day != null) {
        result = _Date.Unit.DAY;
      } else {
        return result;
      }

      return result;
    }
  }, {
    key: "toLuxonDateTime",
    value: function toLuxonDateTime() {
      return luxon.DateTime.fromObject({
        year: this.year,
        month: this.month,
        day: this.day,
        zone: luxon.FixedOffsetZone.utcInstance
      });
    }
  }, {
    key: "toLuxonUncertainty",
    value: function toLuxonUncertainty() {
      var low = this.toLuxonDateTime();
      var high = low.endOf(this.getPrecision()).startOf('day'); // Date type is always at T00:00:00.0

      return new Uncertainty(low, high);
    }
  }, {
    key: "toJSDate",
    value: function toJSDate() {
      var _ref = [this.year, this.month != null ? this.month - 1 : 0, this.day != null ? this.day : 1],
          y = _ref[0],
          mo = _ref[1],
          d = _ref[2];
      return new jsDate(y, mo, d);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toString();
    }
  }, {
    key: "toString",
    value: function toString() {
      var str = '';

      if (this.year != null) {
        str += this.year.toString();

        if (this.month != null) {
          str += '-' + this.month.toString().padStart(2, '0');

          if (this.day != null) {
            str += '-' + this.day.toString().padStart(2, '0');
          }
        }
      }

      return str;
    }
  }, {
    key: "getDateTime",
    value: function getDateTime() {
      // from the spec: the result will be a DateTime with the time components set to zero,
      // except for the timezone offset, which will be set to the timezone offset of the evaluation
      // request timestamp. (this last part is acheived by just not passing in timezone offset)
      if (this.year != null && this.month != null && this.day != null) {
        return new DateTime(this.year, this.month, this.day, 0, 0, 0, 0); // from spec: no component may be specified at a precision below an unspecified precision.
        // For example, hour may be null, but if it is, minute, second, and millisecond must all be null as well.
      } else {
        return new DateTime(this.year, this.month, this.day);
      }
    }
  }, {
    key: "reducedPrecision",
    value: function reducedPrecision() {
      var unitField = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _Date.Unit.DAY;
      var reduced = this.copy();

      if (unitField !== _Date.Unit.DAY) {
        var fieldIndex = _Date.FIELDS.indexOf(unitField);

        var fieldsToRemove = _Date.FIELDS.slice(fieldIndex + 1);

        var _iterator2 = _createForOfIteratorHelper(fieldsToRemove),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var field = _step2.value;
            reduced[field] = null;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      return reduced;
    }
  }, {
    key: "isDate",
    get: function get() {
      return true;
    }
  }], [{
    key: "fromJSDate",
    value: function fromJSDate(date) {
      if (date instanceof _Date) {
        return date;
      }

      return new _Date(date.getFullYear(), date.getMonth() + 1, date.getDate());
    }
  }, {
    key: "fromLuxonDateTime",
    value: function fromLuxonDateTime(luxonDT) {
      if (luxonDT instanceof _Date) {
        return luxonDT;
      }

      return new _Date(luxonDT.year, luxonDT.month, luxonDT.day);
    }
  }]);

  return _Date;
}();

var MIN_DATETIME_VALUE = DateTime.parse('0001-01-01T00:00:00.000');
var MAX_DATETIME_VALUE = DateTime.parse('9999-12-31T23:59:59.999');

var MIN_DATE_VALUE = _Date.parse('0001-01-01');

var MAX_DATE_VALUE = _Date.parse('9999-12-31');

var MIN_TIME_VALUE = DateTime.parse('0000-01-01T00:00:00.000').getTime();
var MAX_TIME_VALUE = DateTime.parse('0000-01-01T23:59:59.999').getTime();
_Date.Unit = {
  YEAR: 'year',
  MONTH: 'month',
  WEEK: 'week',
  DAY: 'day'
};
_Date.FIELDS = [_Date.Unit.YEAR, _Date.Unit.MONTH, _Date.Unit.DAY]; // Shared Funtions For Date and DateTime

DateTime.prototype.isPrecise = _Date.prototype.isPrecise = function () {
  var _this = this;

  return this.constructor.FIELDS.every(function (field) {
    return _this[field] != null;
  });
};

DateTime.prototype.isImprecise = _Date.prototype.isImprecise = function () {
  return !this.isPrecise();
}; // This function can take another Date-ish object, or a precision string (e.g. 'month')


DateTime.prototype.isMorePrecise = _Date.prototype.isMorePrecise = function (other) {
  if (typeof other === 'string' && this.constructor.FIELDS.includes(other)) {
    if (this[other] == null) {
      return false;
    }
  } else {
    var _iterator3 = _createForOfIteratorHelper(this.constructor.FIELDS),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var field = _step3.value;

        if (other[field] != null && this[field] == null) {
          return false;
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }

  return !this.isSamePrecision(other);
}; // This function can take another Date-ish object, or a precision string (e.g. 'month')


DateTime.prototype.isLessPrecise = _Date.prototype.isLessPrecise = function (other) {
  return !this.isSamePrecision(other) && !this.isMorePrecise(other);
}; // This function can take another Date-ish object, or a precision string (e.g. 'month')


DateTime.prototype.isSamePrecision = _Date.prototype.isSamePrecision = function (other) {
  if (typeof other === 'string' && this.constructor.FIELDS.includes(other)) {
    return other === this.getPrecision();
  }

  var _iterator4 = _createForOfIteratorHelper(this.constructor.FIELDS),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var field = _step4.value;

      if (this[field] != null && other[field] == null) {
        return false;
      }

      if (this[field] == null && other[field] != null) {
        return false;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return true;
};

DateTime.prototype.equals = _Date.prototype.equals = function (other) {
  return compareWithDefaultResult(this, other, null);
};

DateTime.prototype.equivalent = _Date.prototype.equivalent = function (other) {
  return compareWithDefaultResult(this, other, false);
};

DateTime.prototype.sameAs = _Date.prototype.sameAs = function (other, precision) {
  if (!(other.isDate || other.isDateTime)) {
    return null;
  } else if (this.isDate && other.isDateTime) {
    return this.getDateTime().sameAs(other, precision);
  } else if (this.isDateTime && other.isDate) {
    other = other.getDateTime();
  }

  if (precision != null && this.constructor.FIELDS.indexOf(precision) < 0) {
    throw new Error("Invalid precision: ".concat(precision));
  } // make a copy of other in the correct timezone offset if they don't match.


  if (this.timezoneOffset !== other.timezoneOffset) {
    other = other.convertToTimezoneOffset(this.timezoneOffset);
  }

  var _iterator5 = _createForOfIteratorHelper(this.constructor.FIELDS),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var field = _step5.value;

      // if both have this precision defined
      if (this[field] != null && other[field] != null) {
        // if they are different then return with false
        if (this[field] !== other[field]) {
          return false;
        } // if both dont have this precision, return true of precision is not defined

      } else if (this[field] == null && other[field] == null) {
        if (precision == null) {
          return true;
        } else {
          // we havent met precision yet
          return null;
        } // otherwise they have inconclusive precision, return null

      } else {
        return null;
      } // if precision is defined and we have reached expected precision, we can leave the loop


      if (precision != null && precision === field) {
        break;
      }
    } // if we made it here, then all fields matched.

  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  return true;
};

DateTime.prototype.sameOrBefore = _Date.prototype.sameOrBefore = function (other, precision) {
  if (!(other.isDate || other.isDateTime)) {
    return null;
  } else if (this.isDate && other.isDateTime) {
    return this.getDateTime().sameOrBefore(other, precision);
  } else if (this.isDateTime && other.isDate) {
    other = other.getDateTime();
  }

  if (precision != null && this.constructor.FIELDS.indexOf(precision) < 0) {
    throw new Error("Invalid precision: ".concat(precision));
  } // make a copy of other in the correct timezone offset if they don't match.


  if (this.timezoneOffset !== other.timezoneOffset) {
    other = other.convertToTimezoneOffset(this.timezoneOffset);
  }

  var _iterator6 = _createForOfIteratorHelper(this.constructor.FIELDS),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var field = _step6.value;

      // if both have this precision defined
      if (this[field] != null && other[field] != null) {
        // if this value is less than the other return with true. this is before other
        if (this[field] < other[field]) {
          return true; // if this value is greater than the other return with false. this is after
        } else if (this[field] > other[field]) {
          return false;
        } // execution continues if the values are the same
        // if both dont have this precision, return true if precision is not defined

      } else if (this[field] == null && other[field] == null) {
        if (precision == null) {
          return true;
        } else {
          // we havent met precision yet
          return null;
        } // otherwise they have inconclusive precision, return null

      } else {
        return null;
      } // if precision is defined and we have reached expected precision, we can leave the loop


      if (precision != null && precision === field) {
        break;
      }
    } // if we made it here, then all fields matched and they are same

  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  return true;
};

DateTime.prototype.sameOrAfter = _Date.prototype.sameOrAfter = function (other, precision) {
  if (!(other.isDate || other.isDateTime)) {
    return null;
  } else if (this.isDate && other.isDateTime) {
    return this.getDateTime().sameOrAfter(other, precision);
  } else if (this.isDateTime && other.isDate) {
    other = other.getDateTime();
  }

  if (precision != null && this.constructor.FIELDS.indexOf(precision) < 0) {
    throw new Error("Invalid precision: ".concat(precision));
  } // make a copy of other in the correct timezone offset if they don't match.


  if (this.timezoneOffset !== other.timezoneOffset) {
    other = other.convertToTimezoneOffset(this.timezoneOffset);
  }

  var _iterator7 = _createForOfIteratorHelper(this.constructor.FIELDS),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var field = _step7.value;

      // if both have this precision defined
      if (this[field] != null && other[field] != null) {
        // if this value is greater than the other return with true. this is after other
        if (this[field] > other[field]) {
          return true; // if this value is greater than the other return with false. this is before
        } else if (this[field] < other[field]) {
          return false;
        } // execution continues if the values are the same
        // if both dont have this precision, return true if precision is not defined

      } else if (this[field] == null && other[field] == null) {
        if (precision == null) {
          return true;
        } else {
          // we havent met precision yet
          return null;
        } // otherwise they have inconclusive precision, return null

      } else {
        return null;
      } // if precision is defined and we have reached expected precision, we can leave the loop


      if (precision != null && precision === field) {
        break;
      }
    } // if we made it here, then all fields matched and they are same

  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return true;
};

DateTime.prototype.before = _Date.prototype.before = function (other, precision) {
  if (!(other.isDate || other.isDateTime)) {
    return null;
  } else if (this.isDate && other.isDateTime) {
    return this.getDateTime().before(other, precision);
  } else if (this.isDateTime && other.isDate) {
    other = other.getDateTime();
  }

  if (precision != null && this.constructor.FIELDS.indexOf(precision) < 0) {
    throw new Error("Invalid precision: ".concat(precision));
  } // make a copy of other in the correct timezone offset if they don't match.


  if (this.timezoneOffset !== other.timezoneOffset) {
    other = other.convertToTimezoneOffset(this.timezoneOffset);
  }

  var _iterator8 = _createForOfIteratorHelper(this.constructor.FIELDS),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var field = _step8.value;

      // if both have this precision defined
      if (this[field] != null && other[field] != null) {
        // if this value is less than the other return with true. this is before other
        if (this[field] < other[field]) {
          return true; // if this value is greater than the other return with false. this is after
        } else if (this[field] > other[field]) {
          return false;
        } // execution continues if the values are the same
        // if both dont have this precision, return false if precision is not defined

      } else if (this[field] == null && other[field] == null) {
        if (precision == null) {
          return false;
        } else {
          // we havent met precision yet
          return null;
        } // otherwise they have inconclusive precision, return null

      } else {
        return null;
      } // if precision is defined and we have reached expected precision, we can leave the loop


      if (precision != null && precision === field) {
        break;
      }
    } // if we made it here, then all fields matched and they are same

  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }

  return false;
};

DateTime.prototype.after = _Date.prototype.after = function (other, precision) {
  if (!(other.isDate || other.isDateTime)) {
    return null;
  } else if (this.isDate && other.isDateTime) {
    return this.getDateTime().after(other, precision);
  } else if (this.isDateTime && other.isDate) {
    other = other.getDateTime();
  }

  if (precision != null && this.constructor.FIELDS.indexOf(precision) < 0) {
    throw new Error("Invalid precision: ".concat(precision));
  } // make a copy of other in the correct timezone offset if they don't match.


  if (this.timezoneOffset !== other.timezoneOffset) {
    other = other.convertToTimezoneOffset(this.timezoneOffset);
  }

  var _iterator9 = _createForOfIteratorHelper(this.constructor.FIELDS),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var field = _step9.value;

      // if both have this precision defined
      if (this[field] != null && other[field] != null) {
        // if this value is greater than the other return with true. this is after other
        if (this[field] > other[field]) {
          return true; // if this value is greater than the other return with false. this is before
        } else if (this[field] < other[field]) {
          return false;
        } // execution continues if the values are the same
        // if both dont have this precision, return false if precision is not defined

      } else if (this[field] == null && other[field] == null) {
        if (precision == null) {
          return false;
        } else {
          // we havent met precision yet
          return null;
        } // otherwise they have inconclusive precision, return null

      } else {
        return null;
      } // if precision is defined and we have reached expected precision, we can leave the loop


      if (precision != null && precision === field) {
        break;
      }
    } // if we made it here, then all fields matched and they are same

  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  return false;
};

DateTime.prototype.add = _Date.prototype.add = function (offset, field) {
  if (offset === 0 || this.year == null) {
    return this.copy();
  } // Use luxon to do the date math because it honors DST and it has the leap-year/end-of-month semantics we want.
  // NOTE: The luxonDateTime will contain default values where this[unit] is null, but we'll account for that.


  var luxonDateTime = this.toLuxonDateTime(); // From the spec: "The operation is performed by converting the time-based quantity to the most precise value
  // specified in the date/time (truncating any resulting decimal portion) and then adding it to the date/time value."
  // However, since you can't really convert days to months,  if "this" is less precise than the field being added, we can
  // add to the earliest possible value of "this" or subtract from the latest possible value of "this" (depending on the
  // sign of the offset), and then null out the imprecise fields again after doing the calculation.  Due to the way
  // luxonDateTime is constructed above, it is already at the earliest value, so only adjust if the offset is negative.

  var offsetIsMorePrecise = this[field] == null; //whether the quantity we are adding is more precise than "this".

  if (offsetIsMorePrecise && offset < 0) {
    luxonDateTime = luxonDateTime.endOf(this.getPrecision());
  } // Now do the actual math and convert it back to a Date/DateTime w/ originally null fields nulled out again


  var luxonResult = luxonDateTime.plus(_defineProperty({}, field, offset));
  var result = this.constructor.fromLuxonDateTime(luxonResult).reducedPrecision(this.getPrecision()); // Luxon never has a null offset, but sometimes "this" does, so reset to null if applicable

  if (this.isDateTime && this.timezoneOffset == null) {
    result.timezoneOffset = null;
  } // Can't use overflowsOrUnderflows from math.js due to circular dependencies when we require it


  if (result.after(MAX_DATETIME_VALUE || result.before(MIN_DATETIME_VALUE))) {
    return null;
  } else {
    return result;
  }
};

DateTime.prototype.getFieldFloor = _Date.prototype.getFieldFloor = function (field) {
  switch (field) {
    case 'month':
      return 1;

    case 'day':
      return 1;

    case 'hour':
      return 0;

    case 'minute':
      return 0;

    case 'second':
      return 0;

    case 'millisecond':
      return 0;

    default:
      throw new Error('Tried to floor a field that has no floor value: ' + field);
  }
};

DateTime.prototype.getFieldCieling = _Date.prototype.getFieldCieling = function (field) {
  switch (field) {
    case 'month':
      return 12;

    case 'day':
      return daysInMonth(this.year, this.month);

    case 'hour':
      return 23;

    case 'minute':
      return 59;

    case 'second':
      return 59;

    case 'millisecond':
      return 999;

    default:
      throw new Error('Tried to clieling a field that has no cieling value: ' + field);
  }
};

function compareWithDefaultResult(a, b, defaultResult) {
  // return false there is a type mismatch
  if ((!a.isDate || !b.isDate) && (!a.isDateTime || !b.isDateTime)) {
    return false;
  } // make a copy of other in the correct timezone offset if they don't match.


  if (a.timezoneOffset !== b.timezoneOffset) {
    b = b.convertToTimezoneOffset(a.timezoneOffset);
  }

  var _iterator10 = _createForOfIteratorHelper(a.constructor.FIELDS),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var field = _step10.value;

      // if both have this precision defined
      if (a[field] != null && b[field] != null) {
        // For the purposes of comparison, seconds and milliseconds are combined
        // as a single precision using a decimal, with decimal equality semantics
        if (field === 'second') {
          // NOTE: if millisecond is null it will calcualte like this anyway, but
          // if millisecond is undefined, using it will result in NaN calculations
          var aMillisecond = a['millisecond'] != null ? a['millisecond'] : 0;
          var aSecondAndMillisecond = a[field] + aMillisecond / 1000;
          var bMillisecond = b['millisecond'] != null ? b['millisecond'] : 0;
          var bSecondAndMillisecond = b[field] + bMillisecond / 1000; // second/millisecond is the most precise comparison, so we can directly return

          return aSecondAndMillisecond === bSecondAndMillisecond;
        } // if they are different then return with false


        if (a[field] !== b[field]) {
          return false;
        } // if both dont have this precision, return true

      } else if (a[field] == null && b[field] == null) {
        return true; // otherwise they have inconclusive precision, return defaultResult
      } else {
        return defaultResult;
      }
    } // if we made it here, then all fields matched.

  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }

  return true;
}

function daysInMonth(year, month) {
  if (year == null || month == null) {
    throw new Error('daysInMonth requires year and month as arguments');
  } // Month is 1-indexed here because of the 0 day


  return new jsDate(year, month, 0).getDate();
}

function isValidDateStringFormat(string) {
  if (typeof string !== 'string') {
    return false;
  }

  var format = LENGTH_TO_DATE_FORMAT_MAP.get(string.length);

  if (format == null) {
    return false;
  }

  return luxon.DateTime.fromFormat(string, format).isValid;
}

function isValidDateTimeStringFormat(string) {
  if (typeof string !== 'string') {
    return false;
  } // Luxon doesn't support +hh offset, so change it to +hh:00


  if (/T[\d:.]*[+-]\d{2}$/.test(string)) {
    string += ':00';
  }

  var formats = LENGTH_TO_DATETIME_FORMATS_MAP.get(string.length);

  if (formats == null) {
    return false;
  }

  return formats.some(function (fmt) {
    return luxon.DateTime.fromFormat(string, fmt).isValid;
  });
}

module.exports = {
  DateTime: DateTime,
  Date: _Date,
  MIN_DATETIME_VALUE: MIN_DATETIME_VALUE,
  MAX_DATETIME_VALUE: MAX_DATETIME_VALUE,
  MIN_DATE_VALUE: MIN_DATE_VALUE,
  MAX_DATE_VALUE: MAX_DATE_VALUE,
  MIN_TIME_VALUE: MIN_TIME_VALUE,
  MAX_TIME_VALUE: MAX_TIME_VALUE
}; // Require MIN/MAX here because math.js requires this file, and when we make this file require
// math.js before it exports DateTime and Date, it errors due to the circular dependency...
// const { MAX_DATETIME_VALUE, MIN_DATETIME_VALUE } = require('../util/math');